//*****************************************************************************
//
//		slabddscat
//
//		v. 3.3-20130906
//
//		2013 - Nicola Ferralis - ferralis@mit.edu
//
//		Create slabs out of adjacent spheres to be used in DDSCAT
//		in the framework of "Spheres"
//
//
//		This program (source code and binaries) is free software;
//		you can redistribute it and/or modify it under the terms of the
//		GNU General Public License as published by the Free Software
//		Foundation, in version 3 of the License.
//
//		This program is distributed in the hope that it will be useful,
//		but WITHOUT ANY WARRANTY; without even the implied warranty of
//		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//		GNU General Public License for more details.
//
//		You can find a complete copy of the GNU General Public License at:
//		http://www.gnu.org/licenses/gpl.txt
//
//******************************************************************************

#include <sys/types.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <unistd.h>
#include <fstream>
#include <iostream>
#include <string.h>
#include <math.h>
#include <stdio.h>
#include <errno.h>
#include <time.h>
using namespace std;

int operate(char *namein);
void createNew();

char version[]="3.3-201300906";
char extension[]="dds.";
char extensiontarg[]=".targ";
char nameout[]="slab_ddscat_sample.txt";


int main(int argc, char *argv[])
{
    
    if(argc<2)
	{cout<< "\n slabddscat v."<<version<< "\n\n";
    cout<< " Usage:\n slabddscat <filename> \n";
    cout<<" To create a new source file: slabddscat -n \n\n";}
    
    if(argc>=2)
	{   if(strcmp(argv[1],"-n")==0)
            {createNew();}
        else
           {operate(argv[1]);}

    return 0;
    }
}


//OPERATE 
int operate(char *namein)

{   int numLayer = 1;
    int maxLayers = 10;
    double X[maxLayers], ymin[maxLayers], ymax[maxLayers];
    double zmin[maxLayers], zmax[maxLayers], R[maxLayers], prec[maxLayers];
    double Y[maxLayers], Z[maxLayers];
    int zpoints[maxLayers], ypoints[maxLayers], comp[maxLayers];
    bool targfile = true;
    
    int numSpheres =0;
    
    ifstream infile(namein);
	
    if(!infile)
    {cout<<"\n file '"<< namein<<"' not found\n\n";
		return 0;}
    
    cout<<"\n Creating slab from: "<<namein<<"\n";
    
    cout<<"\n Layer\tcomp\tx\tymin\tymax\tzmin\tzmax\tradius\tprec\tzpnts\typnts\n";

    
    string line;
    
    getline(infile, line);
    getline(infile, line);
    targfile=(bool) atof(line.c_str());
    
    getline(infile, line);
    getline(infile, line);
    numLayer=(int) atof(line.c_str());
    
    for (int n=0; n<numLayer; n++) {
            getline(infile, line);
            getline(infile, line);
            comp[n]=atof(line.c_str());
        
            getline(infile, line);
            getline(infile, line);
            X[n]=atof(line.c_str());
    
            getline(infile, line);
            getline(infile, line);
            ymin[n]=atof(line.c_str());
    
            getline(infile, line);
            getline(infile, line);
            ymax[n]=atof(line.c_str());
    
            getline(infile, line);
            getline(infile, line);
            zmin[n]=atof(line.c_str());
    
            getline(infile, line);
            getline(infile, line);
            zmax[n]=atof(line.c_str());

            getline(infile, line);
            getline(infile, line);
            R[n]=atof(line.c_str());
    
            getline(infile, line);
            getline(infile, line);
            prec[n]=atof(line.c_str());
        
        cout<<" "<<n+1<<"\t"<<comp[n]<<"\t";
        cout<<X[n]<<"\t"<<ymin[n]<<"\t"<<ymax[n];
        cout<<"\t"<<zmin[n]<<"\t"<<zmax[n]<<"\t"<<R[n]<<"\t"<<prec[n]<<"\t";
    
        zpoints[n] = (int) (zmax[n]-zmin[n])/prec[n];
        ypoints[n] = (int) (ymax[n]-ymin[n])/prec[n];
        cout<<zpoints[n]<<"\t"<<ypoints[n]<<"\n";

        numSpheres += (zpoints[n]+1)*(ypoints[n]+1);
    }

    infile.close();
    
    char* outname;
    
    if(targfile==false) {
        outname=strcat(extension,namein);
    }
    
    else {
        char tempname[100];
        strncpy(tempname, namein,strlen(namein)-4);
        outname=strcat(tempname,extensiontarg);
    }
        
    
    ofstream outfile(outname);
    
    if(targfile==true) {
        outfile<<"\t\t"<<numSpheres+1;
        outfile<<"\n Sphere + slab generated by slabddscat\n";
        outfile<<"  0.390732 -0.920504 -0.000001 = A_1 vector\n";
        outfile<<"  0.920504  0.390732  0.000000 = A_2 vector\n";
        outfile<<"\t x(j)        y(j)        z(j)      a(j)    IC1 IC2 IC3 th,ph,be\n";
        outfile<<"\t0.000000    0.000000    0.000000  1.000000 1    1   1   0 0 0 \n";
    }
    
    
    for (int n=0; n<numLayer; n++) {
    
        for (int i=0; i<=zpoints[n]; i++) {
            Z[n]=zmin[n]+i*prec[n];
            for (int j=0; j<=ypoints[n]; j++) {
        
                Y[n]=ymin[n]+j*prec[n];
      
                outfile<<"\t"<<X[n]<<"\t"<<Y[n]<<"\t"<<Z[n]<<"\t"<<R[n]<<"\t"<<comp[n]<<"\t"<<comp[n]<<"\t"<<comp[n]<<"\t0\t0\t0\n";
            }
        }
    }
    


    outfile.close();
  
 
    cout<<"\n Saved in: "<<outname;

    cout<<"\n\n Number of spheres included slab saved: "<<numSpheres<<"\n\n";
return 0;}
           
           
void createNew(){
    ofstream outfile(nameout);
    outfile<<"# output file: (1: target for ddscat) (0: coordinates only)\n1\n";
    outfile<<"# number of layers\n2\n# composition - layer 1\n1\n# x - layer 1\n1.5\n# ymin - layer 1\n-2\n# ymax - layer 1\n2\n# zmin - layer 1\n-2\n# zmax - layer 1\n2\n# radius - layer 1\n0.5\n# precision - layer 1\n0.1\n";
    outfile<<"# composition - layer 2\n1\n# x - layer 2\n2.5\n# ymin - layer 2\n-2\n# ymax - layer 2\n2\n# zmin - layer 2\n-2\n# zmax - layer 2\n2\n# radius - layer 2\n0.5\n# precision - layer 2\n0.1\n";
    outfile.close();
    cout<<"\n Saved in: "<<nameout<<"\n\n";

}


